/*
 * mkjamb.c - turn Jambase into a big C structure
 *
 * Usage: mkjamb jambase.c Jambase ...
 *
 * Results look like this:
 *
 *       char *jambase[] = {
 *       "...\n",
 *       ...
 *       0 };
 *
 * Handles \'s and "'s specially; knows to delete blank and comment lines.
 */


/*** Includes */
#include "bool.h"
#include "cstd.h"


/*** Defines */
#define BUF_SZ 1024


/*** Function Prototypes */
static void failStderr PARAM((void));
static void failUsage  PARAM((void));
static void failWrite  PARAM((void));
static void putSz      PARAM((char const *));
static void putCh      PARAM((int));
        int main       PARAM((int, char const *const *));


/*** Global Variables */
static char const  szPrgName[] = "mkjamb";
static char const *pszCmdName  = szPrgName;
static char const *pszFileOut  = NIL(char const *);
static FILE       *hFileWrite  = NIL(FILE *);


static void
failStderr NULLARY
BEGIN
    assert(pszCmdName != NIL(char const *));

    UNUSED(fprintf(stderr, "%s: FATAL: could not write stderr.\n",
                   pszCmdName));
    exit(EXITFAIL);
END_FUNCTION(failStdErr)


static void
failUsage NULLARY
BEGIN
    assert(pszCmdName != NIL(char const *));

    if(fprintf(stderr, "%s: usage: %s jambase.c Jambase ...\n",
               pszCmdName, szPrgName) < 0)
    {
        failStderr();
    }
    exit(EXITFAIL);
END_FUNCTION(failUsage)


static void
failWrite NULLARY
BEGIN
    assert(pszCmdName != NIL(char const *));
    assert(pszFileOut != NIL(char const *));

    if(fprintf(stderr, "%s: FATAL: could not write %s.\n",
               pszCmdName, pszFileOut) < 0)
    {
        failStderr();
    }
    exit(EXITFAIL);
END_FUNCTION(failWrite)


static void
putSz DECLARE((sz))
    char const  *const sz  EP
BEGIN
    assert(hFileWrite != NIL(FILE *));
    assert(sz != NIL(char const *));

    if(fputs(sz, hFileWrite) == EOF) {
        failWrite();
    }
END_FUNCTION(putSz)


static void
putCh DECLARE((ch))
    int  const ch  EP
BEGIN
    assert(hFileWrite != NIL(FILE *));

    if(putc(ch, hFileWrite) == EOF) {
        failWrite();
    }
END_FUNCTION(putCh)


int
main DECLARE((argc, argv))
    int                argc  NP
    char const *const *argv  EP
BEGIN
    char         buf[BUF_SZ];  /* flawfinder: ignore */
    char const  *p;
    boolT        doDotC = FALSE;

    assert(argc >= 0);
    assert(argv != NIL(const char * const*));

    if(argc < 1) {
        failUsage();
    }
    pszCmdName = argv[0];
    if(argc < 3) {
        failUsage();
    }

    /* flawfinder: ignore */
    if((hFileWrite = fopen(argv[1], "w")) == NIL(FILE *)) {
        perror(argv[1]);
        exit(EXITFAIL);
    }
    pszFileOut = argv[1];

    /* If the file ends in .c generate a C source file */
    if((p = strrchr(argv[1], '.')) != NIL(char*) && strcmp(p, ".c") == 0) {
        doDotC = TRUE;
    }

    /* Now process the files */
    argc -= 2; argv += 2;

    if(doDotC) {
        putSz("/* Generated by mkjamb from Jambase */\n");
        putSz("#include \"cstd.h\"\n");
        putSz("char const *jambase[] = {\n");
    }

    while(argc-- > 0) {
        /* flawfinder: ignore */
        FILE *fin = fopen(*argv, "r");

        if(fin == NIL(FILE *)) {
            perror(*argv);
            exit(EXITFAIL);
        }

        if(doDotC) {
            putSz("/* "); putSz(*argv); putSz(" */\n");
        } else {
            putSz("### "); putSz(*argv); putSz(" ###\n");
        }

        while(fgets(buf, (int)sizeof(buf), fin) != NIL(char *)) {
            if(doDotC) {
                p = buf;

                /* Strip leading whitespace. */
                while(*p == ' ' || *p == '\t' || *p == '\n') {
                    ++p;
                }

                /* Drop comments and empty lines. */
                if(*p == '#' || *p == '\0') {
                    continue;
                }

                /* Copy */
                putCh('"');

                for(; *p != '\0' && *p != '\n' && *p != '\r'; ++p) {
                    switch(*p) {
                    case '\\':
                        putCh('\\');
                        putCh('\\');
                        break;
                    case '"':
                        putCh('\\');
                        putCh('"');
                        break;
                    default:
                        putCh((int)*p);
                        break;
                    }
                }

                putSz("\\n\",\n");
            } else {
                putSz(buf);
            }
        } /* inner while */

        if(fclose(fin) == EOF) {
            perror(*argv);
            exit(EXITFAIL);
        }

        argv++;
    } /* outer while */

    if(doDotC) {
        putSz("0 };\n");
    }

    if(fclose(hFileWrite) == EOF) {
        perror(argv[1]);
        exit(EXITFAIL);
    }

    return(0);
END_FUNCTION(main)

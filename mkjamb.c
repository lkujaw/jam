/*
 * mkjamb.c - turn Jambase into a big C structure
 *
 * Usage: mkjamb jambase.c Jambase ...
 *
 * Results look like this:
 *
 *       char *jambase[] = {
 *       "...\n",
 *       ...
 *       0 };
 *
 * Handles \'s and "'s specially; knows to delete blank and comment lines.
 */

#include "ansi.h"
#include "bool.h"

#define BUF_SZ 1024

/*** Function Prototypes */
static void failStderr _ARG_((void));
static void failUsage  _ARG_((void));
static void failWrite  _ARG_((void));
static void putSz      _ARG_((char const *));
static void putCh      _ARG_((int));
        int main       _ARG_((int, char **));

/*** Global Variables */
static char const  szPrgName[] = "mkjamb";
static char const *pszCmdName  = szPrgName;
static char const *pszFileOut  = _NIL_(char const *);
static FILE       *hFileWrite  = _NIL_(FILE *);

static void
failStderr()
{
    assert(pszCmdName != _NIL_(char const *));

    (void)fprintf(stderr, "%s: FATAL: could not write stderr.\n",
                  pszCmdName);
    exit(EXITFAIL);
}

static void
failUsage()
{
    assert(pszCmdName != _NIL_(char const *));

    if(fprintf(stderr, "%s: usage: %s jambase.c Jambase ...\n",
               pszCmdName, szPrgName) < 0)
    {
        failStderr();
    }
    exit(EXITFAIL);
}

static void
failWrite()
{
    assert(pszCmdName != _NIL_(char const *));
    assert(pszFileOut != _NIL_(char const *));

    if(fprintf(stderr, "%s: FATAL: could not write %s.\n",
               pszCmdName, pszFileOut) < 0)
    {
        failStderr();
    }
    exit(EXITFAIL);
}

static void
putSz(sz)
    char const *sz;
{
    assert(hFileWrite != _NIL_(FILE *));
    assert(sz != _NIL_(char const *));

    if(fputs(sz, hFileWrite) == EOF) {
        failWrite();
    }
}

static void
putCh(ch)
    int ch;
{
    assert(hFileWrite != _NIL_(FILE *));

    if(putc(ch, hFileWrite) == EOF) {
        failWrite();
    }
}

int
main(argc, argv)
    int    argc;
    char **argv;
{
    char        buf[BUF_SZ];  /* flawfinder: ignore */
    char const *p;
    boolT       doDotC = FALSE;

    assert(argc >= 0);
    assert(argv != _NIL_(char **));

    if(argc < 1) {
        failUsage();
    }
    pszCmdName = argv[0];
    if(argc < 3) {
        failUsage();
    }

    /* flawfinder: ignore */
    if((hFileWrite = fopen(argv[1], "w")) == _NIL_(FILE *)) {
        perror(argv[1]);
        exit(EXITFAIL);
    }
    pszFileOut = argv[1];

    /* If the file ends in .c generate a C source file */
    if((p = strrchr(argv[1], '.')) != _NIL_(char *) && strcmp(p, ".c") == 0) {
        doDotC = TRUE;
    }

    /* Now process the files */
    argc -= 2; argv += 2;

    if(doDotC) {
        putSz("/* Generated by mkjamb from Jambase */\n");
        putSz("#include \"ansi.h\"\n");
        putSz("char const *jambase[] = {\n");
    }

    while(argc-- > 0) {
        /* flawfinder: ignore */
        FILE *fin = fopen(*argv, "r");

        if(fin == _NIL_(FILE *)) {
            perror(*argv);
            exit(EXITFAIL);
        }

        if(doDotC) {
            putSz("/* "); putSz(*argv); putSz(" */\n");
        } else {
            putSz("### "); putSz(*argv); putSz(" ###\n");
        }

        while(fgets(buf, (int)sizeof(buf), fin) != _NIL_(char *)) {
            if(doDotC) {
                p = buf;

                /* Strip leading whitespace. */
                while(*p == ' ' || *p == '\t' || *p == '\n') {
                    ++p;
                }

                /* Drop comments and empty lines. */
                if(*p == '#' || *p == '\0') {
                    continue;
                }

                /* Copy */
                putCh('"');

                for(; *p != '\0' && *p != '\n' && *p != '\r'; ++p) {
                    switch(*p) {
                    case '\\':
                        putCh('\\');
                        putCh('\\');
                        break;
                    case '"':
                        putCh('\\');
                        putCh('"');
                        break;
                    default:
                        putCh((int)*p);
                        break;
                    }
                }

                putSz("\\n\",\n");
            } else {
                putSz(buf);
            }
        } /* inner while */

        if(fclose(fin) == EOF) {
            perror(*argv);
            exit(EXITFAIL);
        }

        argv++;
    } /* outer while */

    if(doDotC) {
        putSz("0 };\n");
    }

    if(fclose(hFileWrite) == EOF) {
        perror(argv[1]);
        exit(EXITFAIL);
    }

    return(0);
}
